# SPDX-FileCopyrightText: © 2024-2025 Austin Seipp
# SPDX-License-Identifier: Apache-2.0

# check-spdx: a script to check the SPDX license headers of all files in the
# repository that are source code, and ensure they are correct. Run on change
# integration.

import sys, subprocess

# MARK: Bad file prefixes, suffixes, and exact matches
BAD_PREFIXES = [
    # dev files
    ".devcontainer",
    ".envrc",
    ".git",
    ".github",
    # editors
    ".helix",
    ".vscode",
    ".zed",
    # buck stuff: fixups, etc
    "buck/third-party/",
    "buck/prelude/",
    "cellar/bootstrap",
    ".buckconfig.d",
]

BAD_SUFFIXES = [
    ".md",
    ".lock",
    ".txt",
    ".json",
    ".jsonc",
    ".jsonl",
    ".exe",
    ".gitattributes",
    ".gitignore",
    ".ignore",
    ".buckconfig",
    ".buckroot",
    ".generated.bzl",
    "Cargo.toml",
    "reindeer.toml",
]

BAD_FILES = [
    # REASON: autogenerated
    "buck/third-party/rust/BUILD",
    # REASON: these get put on command lines, and are not source code
    "buck/mode/local",
    "buck/mode/cached",
    "buck/mode/cached-upload",
    "buck/mode/remote",
    "buck/mode/debug",
    "buck/mode/release",
    # REASON FIXME TODO (aseipp): this file is technically MIT and not
    # Apache-2.0, and it has a modified copyright year.
    "buck/third-party/mimalloc/rust/lib.rs",
    # REASON: standard license text files don't need SPDX headers
    "buck/lib/oci/LICENSE",
    # REASON: shell rc file without extension
    "tilde/aseipp/dotfiles/direnv/direnvrc",
]


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


# MARK: SPDX check
def has_spdx_header(file: str, lines: list[str]) -> bool:
    years = "2024-2025"

    # Allowed SPDX license identifiers
    allowed_licenses = ["Apache-2.0", "MIT", "BSD-2-Clause", "BSD-3-Clause", "ISC"]
    # Also allow compound licenses with AND/OR
    allowed_compound_licenses = ["Apache-2.0 AND MIT"]

    # Define comment styles for copyright
    bzl_style_copyright = "# SPDX-FileCopyrightText: © {} ".format(years)
    cxx_style_copyright = "// SPDX-FileCopyrightText: © {} ".format(years)
    old_cxx_style_copyright = "/* SPDX-FileCopyrightText: © {} ".format(years)
    ocaml_style_copyright = "(* SPDX-FileCopyrightText: © {} ".format(years)

    # Define comment styles for license (we'll check the license separately)
    bzl_style_license_prefix = "# SPDX-License-Identifier: "
    cxx_style_license_prefix = "// SPDX-License-Identifier: "
    old_cxx_style_license_prefix = "/* SPDX-License-Identifier: "
    ocaml_style_license_prefix = "(* SPDX-License-Identifier: "

    file_styles = {
        ".py": (bzl_style_copyright, bzl_style_license_prefix),
        "BUILD": (bzl_style_copyright, bzl_style_license_prefix),
        "PACKAGE": (bzl_style_copyright, bzl_style_license_prefix),
        ".bzl": (bzl_style_copyright, bzl_style_license_prefix),
        ".bxl": (bzl_style_copyright, bzl_style_license_prefix),
        ".rs": (cxx_style_copyright, cxx_style_license_prefix),
        ".cpp": (cxx_style_copyright, cxx_style_license_prefix),
        ".hpp": (cxx_style_copyright, cxx_style_license_prefix),
        ".h": (cxx_style_copyright, cxx_style_license_prefix),
        ".c": (cxx_style_copyright, cxx_style_license_prefix),
        ".go": (cxx_style_copyright, cxx_style_license_prefix),
        ".ts": (cxx_style_copyright, cxx_style_license_prefix),
        ".js": (cxx_style_copyright, cxx_style_license_prefix),
        ".nix": (bzl_style_copyright, bzl_style_license_prefix),
        ".capnp": (bzl_style_copyright, bzl_style_license_prefix),
        ".S": (cxx_style_copyright, cxx_style_license_prefix),
        ".ld": (old_cxx_style_copyright, old_cxx_style_license_prefix),
        ".ml": (ocaml_style_copyright, ocaml_style_license_prefix),
        ".yaml": (bzl_style_copyright, bzl_style_license_prefix),
        ".fish": (bzl_style_copyright, bzl_style_license_prefix),
        ".toml": (bzl_style_copyright, bzl_style_license_prefix),
    }

    file_ext = None
    for key in file_styles.keys():
        if file == key or file.endswith(key):
            file_ext = key
            break
    if file_ext is None:
        eprint(f"Error: {file} is an unknown file type, hard failing!")
        return False

    copyright_prefix, license_prefix = file_styles[file_ext]

    # Look for one or more copyright lines followed by license line
    i = 0
    copyright_found = False

    # Check for at least one copyright line
    while i < len(lines):
        line = lines[i].strip()
        if line.startswith(copyright_prefix):
            copyright_found = True
            i += 1
        else:
            break

    if not copyright_found:
        eprint(f"Error: {file} does not have the correct SPDX copyright header!")
        return False

    # Check for license line
    if i >= len(lines):
        eprint(f"Error: {file} is missing SPDX license header!")
        return False

    license_line = lines[i].strip()
    if not license_line.startswith(license_prefix):
        eprint(f"Error: {file} does not have the correct SPDX license header format!")
        return False

    # Extract the license identifier
    # Handle different comment closing styles
    license_id = license_line[len(license_prefix):].strip()
    if license_id.endswith(" */"):
        license_id = license_id[:-3].strip()
    elif license_id.endswith(" *)"):
        license_id = license_id[:-3].strip()

    # Check if it's an allowed license
    if license_id not in allowed_licenses and license_id not in allowed_compound_licenses:
        eprint(f"Error: {file} has unsupported license '{license_id}'. Allowed licenses: {', '.join(allowed_licenses + allowed_compound_licenses)}")
        return False

    return True


# MARK: Entry point
def main():
    # run 'jj files' command and get line-by-line output
    files = (
        subprocess.run(
            ["jj", "file", "list"],
            stdout=subprocess.PIPE,
            check=True,
        )
        .stdout.decode("utf-8")
        .strip()
        .splitlines()
    )

    exit_code = 0
    for file in files:
        # normalize \ to / on Windows
        file = file.replace("\\", "/")
        # skip exact matches
        if file in BAD_FILES:
            continue
        # skip files that have bad prefixes
        if any(file.startswith(prefix) for prefix in BAD_PREFIXES):
            continue
        # and bad suffixes
        if any(file.endswith(suffix) for suffix in BAD_SUFFIXES):
            continue

        print(f"Checking {file}...")
        with open(file, "r", encoding="utf-8") as f:
            lines = f.readlines()
            # quick path: if the file starts with '#!' it's a script, skip it
            if lines[0].startswith("#!"):
                continue
            if not has_spdx_header(file, lines):
                exit_code = 1
    exit(exit_code)


if __name__ == "__main__":
    main()
