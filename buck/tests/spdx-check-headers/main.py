# SPDX-FileCopyrightText: © 2024-2025 Austin Seipp
# SPDX-License-Identifier: Apache-2.0

# check-spdx: a script to check the SPDX license headers of all files in the
# repository that are source code, and ensure they are correct. Run on change
# integration.

import sys, subprocess

# MARK: Bad file prefixes, suffixes, and exact matches
BAD_PREFIXES = [
    # dev files
    ".devcontainer",
    ".envrc",
    ".git",
    ".github",
    # editors
    ".helix",
    ".vscode",
    ".zed",
    # buck stuff: fixups, etc
    "buck/third-party/",
    "buck/prelude/",
    "cellar/bootstrap",
    ".buckconfig.d",
]

BAD_SUFFIXES = [
    ".md",
    ".lock",
    ".txt",
    ".json",
    ".jsonc",
    ".jsonl",
    ".exe",
    ".gitattributes",
    ".gitignore",
    ".ignore",
    ".buckconfig",
    ".buckroot",
    ".generated.bzl",
    "Cargo.toml",
    "reindeer.toml",
]

BAD_FILES = [
    # REASON: autogenerated
    "buck/third-party/rust/BUILD",
    # REASON: these get put on command lines, and are not source code
    "buck/mode/local",
    "buck/mode/cached",
    "buck/mode/cached-upload",
    "buck/mode/remote",
    "buck/mode/debug",
    "buck/mode/release",
    # REASON FIXME TODO (aseipp): this file is technically MIT and not
    # Apache-2.0, and it has a modified copyright year.
    "buck/third-party/mimalloc/rust/lib.rs",
    # REASON: standard license text files don't need SPDX headers
    "buck/lib/oci/LICENSE",
]


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


# MARK: SPDX check
def has_spdx_header(file: str, lines: list[str]) -> bool:
    years = "2024-2025"

    # Define comment styles
    bzl_style_copyright = "# SPDX-FileCopyrightText: © {} ".format(years)
    bzl_style_license = "# SPDX-License-Identifier: Apache-2.0"

    cxx_style_copyright = "// SPDX-FileCopyrightText: © {} ".format(years)
    cxx_style_license = "// SPDX-License-Identifier: Apache-2.0"

    old_cxx_style_copyright = "/* SPDX-FileCopyrightText: © {} ".format(years)
    old_cxx_style_license = "/* SPDX-License-Identifier: Apache-2.0 */"

    ocaml_style_copyright = "(* SPDX-FileCopyrightText: © {} ".format(years)
    ocaml_style_license = "(* SPDX-License-Identifier: Apache-2.0 *)"

    file_styles = {
        ".py": (bzl_style_copyright, bzl_style_license),
        "BUILD": (bzl_style_copyright, bzl_style_license),
        "PACKAGE": (bzl_style_copyright, bzl_style_license),
        ".bzl": (bzl_style_copyright, bzl_style_license),
        ".bxl": (bzl_style_copyright, bzl_style_license),
        ".rs": (cxx_style_copyright, cxx_style_license),
        ".cpp": (cxx_style_copyright, cxx_style_license),
        ".hpp": (cxx_style_copyright, cxx_style_license),
        ".h": (cxx_style_copyright, cxx_style_license),
        ".c": (cxx_style_copyright, cxx_style_license),
        ".go": (cxx_style_copyright, cxx_style_license),
        ".ts": (cxx_style_copyright, cxx_style_license),
        ".js": (cxx_style_copyright, cxx_style_license),
        ".nix": (bzl_style_copyright, bzl_style_license),
        ".capnp": (bzl_style_copyright, bzl_style_license),
        ".S": (cxx_style_copyright, cxx_style_license),
        ".ld": (old_cxx_style_copyright, old_cxx_style_license),
        ".ml": (ocaml_style_copyright, ocaml_style_license),
        ".yaml": (bzl_style_copyright, bzl_style_license),
    }

    file_ext = None
    for key in file_styles.keys():
        if file == key or file.endswith(key):
            file_ext = key
            break
    if file_ext is None:
        eprint(f"Error: {file} is an unknown file type, hard failing!")
        return False

    copyright_prefix, license_line = file_styles[file_ext]

    # Look for one or more copyright lines followed by license line
    i = 0
    copyright_found = False

    # Check for at least one copyright line
    while i < len(lines):
        line = lines[i].strip()
        if line.startswith(copyright_prefix):
            copyright_found = True
            i += 1
        else:
            break

    if not copyright_found:
        eprint(f"Error: {file} does not have the correct SPDX header!")
        return False

    # Check for license line
    if i >= len(lines) or not lines[i].strip().startswith(license_line):
        eprint(f"Error: {file} does not have the correct SPDX header!")
        return False

    return True


# MARK: Entry point
def main():
    # run 'jj files' command and get line-by-line output
    files = (
        subprocess.run(
            ["jj", "file", "list"],
            stdout=subprocess.PIPE,
            check=True,
        )
        .stdout.decode("utf-8")
        .strip()
        .splitlines()
    )

    exit_code = 0
    for file in files:
        # normalize \ to / on Windows
        file = file.replace("\\", "/")
        # skip exact matches
        if file in BAD_FILES:
            continue
        # skip files that have bad prefixes
        if any(file.startswith(prefix) for prefix in BAD_PREFIXES):
            continue
        # and bad suffixes
        if any(file.endswith(suffix) for suffix in BAD_SUFFIXES):
            continue

        print(f"Checking {file}...")
        with open(file, "r", encoding="utf-8") as f:
            lines = f.readlines()
            # quick path: if the file starts with '#!' it's a script, skip it
            if lines[0].startswith("#!"):
                continue
            if not has_spdx_header(file, lines):
                exit_code = 1
    exit(exit_code)


if __name__ == "__main__":
    main()
